---
title: "Freshwater Fish Site Analysis"
subtitle: "A Healthy Waters Partnership Analysis"
description: "Script 1 in a series of scripts designed to analyse and score freshwater fish sampled in the Dry Tropics region."
author: "Adam Shand"
format: html
params: 
  target_fyear: 2024
---

# Introduction

This is a simple script to calculate scores and grades for the freshwater Fish indicator category in the Freshwater environment for the Dry Tropics region.

# Script Set Up

This script requires multiple core spatial packages, each of which is loaded below. Key variables and paths are also created.

```{r}
#| label: load packages

#use pacman function to load and install (if required) all other packages
pacman::p_load(dplyr, tidyr, readr, stringr, glue, here, sf, tmap, readxl)

#update/load package
#pak::pak("add-am/RcTools")
library(RcTools)

#define relevant paths
data_path <- glue("{here()}/data/")
output_path <- glue("{here()}/outputs/")

#create folders as needed
dir.create(glue("{output_path}/"), showWarnings = FALSE)

```

# Load Data

Two datasets are required:

 - The northern three region
 - The fish dataset

The northern three dataset is built/loaded with the code below.

```{r}

#check if object exists on file
if (file.exists("data/n3_region.gpkg")){
  n3_region <- st_read("data/n3_region.gpkg")
} else {
  n3_region <- build_n3_region()
  st_write(n3_region, "data/n3_region.gpkg")
}

```

Then fish data is pulled from one master spreadsheet.

```{r}
#| label: bring in data

#load metadata about the species, their full names, and their "type" (indigenous or not)
species_type <- read_excel(glue("{data_path}/raw/dt_freshwater_fish_master.xlsx"),
                      sheet = "Species_Codes", na = c("", "NA", "NULL", "null")) |> 
  name_cleaning()

#load observation data and clean
dt_fish_raw <- read_excel(glue("{data_path}/raw/dt_freshwater_fish_master.xlsx"),
                          sheet = "Surveys", na = c("", "NA", "NULL", "null")) |> 
  name_cleaning() |> 
  select(-c(DbSiteCode, Run, SegmentId, Watercourse, NumberOfIndigenousSpecies, Poise, PropTrans, PropAlien, PropNonIndigenous))

```

# Edit Data

we will then need to edit and manipulate the data as it is not provided in the easiest format to work with in a computer program (human readability was prioritised). Below we will pivot the data longer (move the spp names from column headers to a specific column), and remove all rows in which no observations of the species occurred.

```{r}
#| label: edit data

#pivot data longer (move all species columns into one, and all observations into one), then merge the metadata on
dt_fish <- pivot_longer(dt_fish_raw, cols = 6:ncol(dt_fish_raw), 
                        names_to = "Species", values_to = "Observations") |> 
  merge(species_type) |> 
  filter(Observations != 0)

#calculate the financial year the data was collected in, then convert into an sf object
dt_fish <- dt_fish |> 
  mutate(Fyear = busdater::get_fy(Date)) |> 
  st_as_sf(coords = c("LongWgs84", "LatWgs84"), crs = "EPSG:4326") |> 
  st_transform(st_crs(n3_region))

#intersect with the n3 region to get region, basin and sub basin information
dt_fish <- st_intersection(dt_fish, n3_region)

#make a copy that keeps vernacular and genus
dt_fish_named <- dt_fish

#reorder columns and remove some
dt_fish <- dt_fish |> 
  select(Region, BasinOrZone, SubBasinOrSubZone, Site, Fyear, Date, Species, Type, PredictedNumberOfIndigenousSpecies, Observations)

#we can then put this aside to be used by the visualisation script later. note it goes to the "processed" folder in the main data folder
#write_csv(dt_fish, glue("{data_path}/processed/fish_data.csv"))

```

# Calculate Results

Then we can begin calculating results.

## POISE and PONIS Indicator Categories

Starting with the Proportion of Indigenous Species Expected (POISE) and Proportion of Non-Indigenous Species (PONIS) indicator categories.

```{r}
#| label: calculate results

#write a repeatable function that calculates key stats at the desired level
summarise_fish <- function(df, GroupingVar, Prefix){

  df |> 
    group_by(Region, Fyear, {{GroupingVar}}) |> 
    mutate(
      "{Prefix}TotNumFish" := sum(Observations), #Total number of fish
      "{Prefix}NumUniqIndSpp" := n_distinct(Species[Type == "Indigenous"]), #Number of unique indigenous species
      "{Prefix}TotNumIndFish" := sum(ifelse(Type == "Indigenous", Observations, 0)), #Total number of indigenous fish
      "{Prefix}TotNumNoIFish" := sum(ifelse(Type != "Indigenous", Observations, 0)), #Total number of non indigenous fish
      "{Prefix}TotNumAliFish" := sum(ifelse(Type == "Alien", Observations, 0)), #Total Number of alien fish
      "{Prefix}TotNumTraFish" := sum(ifelse(Type == "Translocated", Observations, 0))) |> #Total number of translocated fish 
    ungroup()
}

#run the function at each level
dt_fish_site <- summarise_fish(dt_fish, Site, "Site")
dt_fish_sub <- summarise_fish(dt_fish_site, SubBasinOrSubZone, "Sub")
dt_fish_basin <- summarise_fish(dt_fish_sub, BasinOrZone, "Basin")

#calculate site POISE and PONIS scores, then aggregate to sub basin and basin levels
dt_fish_basin <- dt_fish_basin |> 
  select(-c(Species, Type, Observations)) |>
  mutate(
    SitePonis = SiteTotNumNoIFish/SiteTotNumFish,
    SitePoise = SiteNumUniqIndSpp/PredictedNumberOfIndigenousSpecies) |> 
      unique() |> 
  group_by(Region, BasinOrZone, SubBasinOrSubZone, Fyear) |> 
  mutate(
    SubPonis = median(SitePonis, na.rm = TRUE),
    SubPoise = median(SitePoise, na.rm = TRUE)) |> 
  group_by(Region, BasinOrZone, Fyear) |> 
  mutate(
    BasinPonis = median(SitePonis, na.rm = TRUE),
    BasinPoise = median(SitePoise, na.rm = TRUE)) |> 
  ungroup()

```

## Standardised Scores

Then we can standardise the scores for each of these indicator categories.

```{r}
#| label: standardise scores

#build a dataframe that contains the required references
cols_to_score <- data.frame(
  Indicator = c("PONIS", "POISE", "PONIS", "POISE", "PONIS", "POISE"),
  ColName = c("SitePonis", "SitePoise", "SubPonis", "SubPoise", "BasinPonis", "BasinPoise")
  )

#iterate over the references
for (i in seq_len(nrow(cols_to_score))){

  #pull arguments into objects
  col <- cols_to_score$ColName[i] 
  ind <- cols_to_score$Indicator[i]

  #run custom scoring function
  dt_fish_basin <- value_to_score(dt_fish_basin, value = !!sym(col), value_type = "Fish", indicator = ind)
}
         
```

## Fish Index

Before calculating the final fish index score for each site, sub basin and basin.

```{r}
#| label: calculate the fish index

#calculate the fish index by taking the mean of each indicator
dt_fish_results <- dt_fish_basin |> 
  rowwise() |> 
  mutate(
    SiteIndex = mean(c(SitePonisScore, SitePoiseScore)),
    SubIndex = mean(c(SubPonisScore, SubPoiseScore)),
    BasinIndex = mean(c(BasinPonisScore, BasinPoiseScore))
    ) |> 
  ungroup() |> 
  mutate(across(contains(c("Score", "Index")), floor))

```

# Outputs

With all calculations completed, outputs can now be produced. We will create:

 - A basin scores summary
 - A sub basin scores summary
 - A site scores summary
 - A count of sites per basin, and number of site visits
 - A count of species per basin
 - A presence/absence summary
 - Maps

## Tables

Below the three summary tables are created.

```{r}

#create a site table
site_summary <- dt_fish_results |> 
  select(
    Region, BasinOrZone, SubBasinOrSubZone, Site, Fyear, 
    SitePonis, SitePoise, SitePonisScore, SitePoiseScore, SiteIndex) |> 
  st_drop_geometry() |> 
  unique()

#create a sub basin table
sub_summary <- dt_fish_results |> 
  select(
    Region, BasinOrZone, SubBasinOrSubZone, Fyear, 
    SubPonis, SubPoise, SubPonisScore, SubPoiseScore, SubIndex) |> 
  st_drop_geometry() |> 
  unique() 

#create a basin table
basin_summary <- dt_fish_results |> 
  select(
    Region, BasinOrZone, Fyear, 
    BasinPonis, BasinPoise, BasinPonisScore, BasinPoiseScore, BasinIndex) |> 
   st_drop_geometry() |> 
   unique() 

#save each
save_n3_table(site_summary, glue("{output_path}/site_summary"), 8:10, scheme = "Report Card")
save_n3_table(sub_summary, glue("{output_path}/sub_summary"), 7:9, scheme = "Report Card")
save_n3_table(basin_summary, glue("{output_path}/basin_summary"), 6:8, scheme = "Report Card")

```

Then the count of sites per basin and number of site visits.

```{r}
#| label: save site summary table

#convert our dataset to a spatial file and add numbers for each site
sites_per_basin_summary <- dt_fish_results |> 
  group_by(BasinOrZone, Site) |> 
  st_drop_geometry() |> 
  arrange(Fyear) |> 
  summarise(Fyear = paste(unique(Fyear), collapse = ",")) |> 
  unique() |> 
  group_by(BasinOrZone) |> 
  arrange(desc(BasinOrZone), Site) |> 
  mutate(SiteNumber = row_number()) |> 
  ungroup()

#save
write_csv(dt_site_summary, glue("{output_path}/appendix_site_counts_and_visits.csv"))

```

Then a count of species per basin.

```{r}
#| label: save species summary table

#create a species summary table
dt_species_summary <- dt_fish_named |> 
  select(BasinOrZone, VernacularName, Type) |> 
  st_drop_geometry() |> 
  unique() |> 
  arrange(BasinOrZone) |> 
  group_by(VernacularName, Type) |> 
  summarise(BasinOrZone = paste(BasinOrZone, collapse = "/")) |> 
  relocate(BasinOrZone, .before = VernacularName) |> 
  arrange(desc(BasinOrZone)) |> 
  ungroup() |> 
  mutate(SpeciesKey = row_number())

#save with the row number included
write_csv(dt_species_summary, glue("{output_path}/appendix_species_per_basin_summary.csv"))

```

and then the presence/absence table is made.

```{r}
#| label: create presence absence table

#select the main rows
dt_presence_summary <- dt_fish |> 
  select(Basin, Site, VernacularName) |> 
  merge(dt_site_summary)

#cut down the key table we just created
dt_species_key <- dt_species_summary |> 
  select(VernacularName, SpeciesKey)

#and merge 
dt_presence_summary <- merge(dt_presence_summary, dt_species_key) |> 
  select(-VernacularName, -Site) |> 
  mutate(presence = 1) |> 
  arrange(SpeciesKey)

#pivot data
dt_presence_summary <- dt_presence_summary |> 
  pivot_wider(names_from = SpeciesKey, values_from = presence) |> 
  mutate(across(everything(), ~replace_na(.x, 0))) |> 
  arrange(desc(Basin), SiteNumber)

#split into Ross and Black
ross_presence <- dt_presence_summary |> 
  filter(Basin == "Ross")

black_presence <- dt_presence_summary |> 
  filter(Basin == "Black")

#and save, using a custom coloring function
source(here("functions/cond_form_fish_pres_abs.R"))

#save data
cond_form_fish_pres_abs(ross_presence, glue("{output_path}/appendix_ross_presence"), cols = c(3, ncol(ross_presence)))
cond_form_fish_pres_abs(black_presence, glue("{output_path}/appendix_black_presence"), cols = c(3, ncol(black_presence)))

```
